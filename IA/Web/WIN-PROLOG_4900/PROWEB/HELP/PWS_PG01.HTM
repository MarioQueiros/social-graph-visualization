<HTML>
<HEAD>
<TITLE>ProWeb Server - How ProWeb Works</TITLE>
</HEAD>
<BODY BACKGROUND="lpa_line.gif" BGCOLOR="#C0C0C0" TEXT="#000080" LINK="#0000FF" VLINK="#00FF00" ALINK="#FF0000">
<TABLE COLS=2>
<TD VALIGN=TOP ALIGN=CENTER>
<IMG SRC="lpa_left.gif">
</TD><TD VALIGN=TOP ALIGN=LEFT><IMG SRC="pws.gif"><P>

<H1>How ProWeb Works</H1>

<OL><FONT SIZE=5>
  <LI> <A HREF="#PG0101"> Introduction                           </A>
  <LI> <A HREF="#PG0102"> The General Problems                   </A>
  <LI> <A HREF="#PG0103"> Some Alternative Solutions             </A>
  <LI> <A HREF="#PG0104"> The ProWeb Solution in more Detail     </A>
  <LI> <A HREF="#PG0105"> The Conversation History               </A>
  <LI> <A HREF="#PG0106"> The Execution Mechanism                </A>
  <LI> <A HREF="#PG0107"> Some Caveats                           </A>
</FONT></OL>

<BR><BR><BR><BR>
<A NAME="PG0101">
<H2>Introduction</H2>
</A NAME="PG0101">

<P>
ProWeb is a tool that enables Prolog SERVER applications to be developed,
tested and ultimately delivered on an NT server-based intranet/internet 
environment.
<P>
ProWeb SERVER applications can easily support conversations with multiple
users, even in the asynchronous mode common to intranet/internet
communications.
<P>

<BR><BR><BR><BR>
<A NAME="PG0102">
<H2>The General Problems</H2>
</A NAME="PG0102">

<P>
There are a number of problems that must be dealt with when handling Web
conversations programmatically. One such problem is that the 
conversations are, according to the nature of the Web, discontiguous. 
A response from a CLIENT to any given HTML page may be immediate, or 
may take place two weeks later and may well be from a new site across 
the other side of the world, and the SERVER has no way of telling the 
difference between the two. It may also be the case that after sending 
out an HTML page the next response that comes in to the SERVER is a 
reply to a previous HTML page in the same conversation or even a 
response from a completely different CLIENT with a completely different 
conversation.
<P>
It would be unreasonable to expect the SERVER application to be running
between the pages of a conversation, especially if the gaps between 
responses are as large as two weeks. It would also be unreasonable to 
expect the SERVER to "lock out" any responses from other CLIENTs during 
this potentially long gap. For these reasons some mechanism for 
identifying the current "status" of a conversation must be in place 
so that the SERVER application can effectively shut down in-between
pages yet still pick up from where it left off when the next response 
eventually does arrive.
<P>

<BR><BR><BR><BR>
<A NAME="PG0103">
<H2>Some Alternative Solutions</H2>
</A NAME="PG0103">

<P>
There are a number of possible solutions to the problems outlined 
above, here are three of the most popular.
<P>

<H3>Saving the Prolog Execution Stack</H3>
<P>
One way of handling this would be to save the current Prolog execution 
stack whenever an HTML page is sent and re-load it when the response 
to that HTML page comes back. A problem with this solution is that 
the saving of the Prolog execution stack is a cumbersome and time 
consuming process that requires large amounts of disk space. Another 
problem is that the execution stack would have to be saved for each 
page of the conversation just in case the CLIENT decides to skip 
back to an earlier page and submit a different response.
<P>

<H3>Initiating Multiple Prolog Threads</H3>
<P>
Another way of handling the problems associated with web communications 
would be to initiate a new Prolog thread for each conversation. This 
would mean that each conversation could be held in memory ready and 
waiting for the next response and able to respond quickly. 
Unfortunately there are problems with this solution as well. 
Aside from the large amount of memory that would be required to hold 
the multiple threads there would be great difficulty in handling 
the case where the CLIENT decides to skip back to an earlier page 
and submit a different response.
<P>

<H3>A Clean and Simple Re-Compute Model</H3>
<P>
The simple and effective approach taken by ProWeb is to always restart 
execution from the application's main procedure and replay the application 
up to the point of the HTML page that has been responded to, using a 
stored history for the conversation. Of course, to do this blindly 
would mean that the application would re-send all the previous pages 
in the conversation and this is plainly not the behaviour required. 
For this reason ProWeb stores not only the replies given to previous 
questions but also which forms have already been sent to get to the 
current point in the conversation, and unless directed otherwise ProWeb 
will not send the same form twice.
<P>

<BR><BR><BR><BR>
<A NAME="PG0104">
<H2>The ProWeb Solution in more Detail</H2>
</A NAME="PG0104">

<P>
In ProWeb each conversation has a uniquely generated ID. A history of 
interactions related to the unique ID is stored on disk and updated 
whenever a response is made to a ProWeb HTML page. The history leading 
up to each page is stored separately, so that at any point during the 
conversation the CLIENT can skip back to a previous page and change 
their original response to generate a new history.
<P>
At each stage the SERVER computes the next HTML form using the history 
of the conversation so far and the Prolog rules defined by the programmer 
as part of the ProWeb SERVER application.
<P>
So are there any problems with the "restart-history" model?
<P>
The only potential major drawback seems to be the apparent waste of 
valuable CPU time, and its effect on the throughput and turnaround time 
of traffic visiting the site.
<P>
Consider an application which takes an extremely long time, say 10 
minutes, to fully execute from start to finish. Assume, also, that the 
conversation between SERVER and CLIENT involves collecting information 
from 9 different forms which are evenly spaced throughout the execution. 
In the ProWeb model the response times would be 1 minute to compute 
the 1st form, a further 2 minutes to compute the 2nd form (total of 
3 minutes), a further 3 minutes to compute the 3rd form (total of 6 
minutes) and so on up to 9 minutes to compute the last form (total of 
45 minutes) and eventually 10 minutes to compute the final result, 
giving a grand total of 55 minutes!
<P>
This potential inefficiency can be solved in a ProWeb application in 
two ways:
<P>
<UL>
<LI>Firstly, you can assume that this is a worst-case scenario which 
is untypical of CLIENT-SERVER applications. Usually, a small proportion 
of time is devoted up front to assessing and gathering the information 
that is required before any bulky computation ensues. So an application 
can be structured to avoid a lot of wasteful re-processing.
<P>
<LI>Secondly, ProWeb provides an easy solution to circumvent this 
problem by allowing you to store information alongside the conversation
history. Thus, partial results can be cached and re-used when the
conversation moves forward to avoid lengthy re-computations.
</UL>
<P>
An example that uses the second technique is the "travelling salesman" 
provided with the ProWeb toolkit. In this example the object is to 
calculate the shortest tour that visits a selected number of towns ending
back at the start point.
<P>
In one of the modes provided an approximate route is first presented to
the CLIENT which can then be refined into a more accurate route. The
approximation is stored alongside the conversation history for the
first HTML page and it is this cached result which is later refined
rather than re-computing it.

<BR><BR><BR><BR>
<A NAME="PG0105">
<H2>The Conversation History</H2>
</A NAME="PG0105">

<P>
The conversation history records all of the HTML forms which have
been sent to the CLIENT prior to the current interaction. In addition,
it records the answers given by the CLIENT to all questions occurring
on those forms.
<P>
The conversation history can either be stored locally on the SERVER
machine or it can be stored remotely on the CLIENT machine.
<P>

<H3>Local Conversational Database</H3>
<P>
Associated with every HTML page sent by a ProWeb SERVER to a CLIENT is a 
hidden pointer. When a page is submitted by that CLIENT and returned to the 
SERVER this pointer is used to reference a unique, local database which 
recorded the conversation leading up to the page being sent. Thus, when the 
information extracted from a returned page is added to this prior information 
the complete picture of the conversation so far is readily available.
<P>
<CENTER><IMG SRC="pws_loc.gif"></CENTER>
<P>

<H3>Remote Conversational Database</H3>
<P>
Associated with every HTML page sent by a ProWeb SERVER to a CLIENT is a 
collection of hidden question-answer pairs. These correspond to the 
information submitted by the CLIENT in all of the preceeding pages.
When this page is submitted by the CLIENT all of the hidden information 
is also returned to the SERVER.
<P>
<CENTER><IMG SRC="pws_rem.gif"></CENTER>
<P>

<BR><BR><BR><BR>
<A NAME="PG0106">
<H2>The Execution Mechanism</H2>
</A NAME="PG0106">

<P>
Armed with the conversation so far the SERVER can compute, by executing 
the application code, the next HTML form sent to the CLIENT. So where in the 
application code does execution begin in order to compute the next form? An 
obvious place is the point at which the previous form was generated, but this 
would require some method of saving and restoring the Prolog execution stack. 
A far simpler solution, and the one employed by ProWeb, is to always restart 
execution at the application's main procedure.
<P>
Now this begs the question that if we always start executing from the same 
point then is it exactly the same form which is sent each time? The answer is 
obviously no because in addition to storing replies given to previous 
questions the conversational database also records which forms have 
been sent and unless directed otherwise ProWeb will not send the same form 
twice.

<P>
Consider an execution trail of some application's main procedure which 
goes something like this :-
<OL>
  <LI>Ask some initial questions.<P>
  <LI>Depending upon the initial answers do some non-deterministic computation.<P>
  <LI>Ask some further questions.<P>
  <LI>Depending upon all the answers given do some non-deterministic computation.<P>
  <LI>Repeat the preceeding two steps until the main procedure terminates and a final result can be given.
</OL>
<P>
In the ProWeb model the main procedure is automatically aborted whenever 
information is required from the CLIENT. Thus, in a fresh conversation the 
main procedure immediately stops at 1 and sends the appropriate forms to 
the CLIENT. When the CLIENT response arrives back the main procedure 
re-starts from the beginning. It skips 1 (equivalent to a <B>true</B> 
goal) and continues onto 2 because ProWeb recognises that these forms have 
already been sent and returned. It now prematurely stops at 3 and some new 
forms are sent to the CLIENT. When these are returned the main procedure 
again re-starts from the beginning, again it skips 1 and again executes 2
in exactly the same way as previously (providing no side-effects have been 
retained). This time it skips 3 (again equivalent to a <B>true</B> goal) 
and continues onto 4. The conversation between CLIENT and SERVER progresses 
in this manner until a natural end occurs when the main procedure 
terminates, either successfully or with failure.
<P>

<BR><BR><BR><BR>
<A NAME="PG0107">
<H2>Some Caveats</H2>
</A NAME="PG0107">

<P>
A complication may arise when the application does cause 
side-effects, either in the internal Prolog database or the operating 
system of the host machine. It is possible, indeed likely, for 
side-effects to make one CLIENT aware of the activities of another 
CLIENT. For example, the conversation might open by congratulating 
the CLIENT on being the 1,000th visitor to the site. 
It may be the SERVER application's intention for side-effects to persist
between invocations but in general it is not. The onus, therefore, is on 
the application author to include preliminary code which ensures each 
invocation of the main procedure starts in more-or-less the same state. 
This is good programming practice in any case.
<P>
A further complication may arise when an application wishes to iterate 
over the same form. For example, an insurance system may involve 
underwriting multiple properties each of which requires a separate address 
form. The problem of sending multiple instances of the address form is 
overcome by allowing forms to be named by general Prolog terms rather 
simple atoms. Thus, an address form could be named by the Prolog term :-

<FONT FACE=courier COLOR=800000 SIZE=2><PRE>
        address( PropertyNumber )
</PRE></FONT>

which would generate different names for different instantiations of 
<I>PropertyNumber</I>.

</TD></TABLE><IMG SRC="lpa_logo.gif">
</BODY>
</HTML>

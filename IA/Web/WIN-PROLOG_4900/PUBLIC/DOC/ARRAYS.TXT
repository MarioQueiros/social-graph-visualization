ARRAYS

%   Author : R.A.O'Keefe
%   Purpose: Updatable arrays in Prolog.

This package gives access to a straightforward implementation of
updatable arrays. 

In this package an array is represented in the following notation

	{1,2,3} is shown initially as array([1|_1],[2|_2],[3|_3])+0

where the [1|_1] etc. are lists in which the most recent value for
the element comes last, and the +0 is a zero updates count.
Updating the 2nd element to a 5 for example would make the array into

	array([1|_1],[2,5|_2],[3|_3])+1.

The operations made available by this package are fully described in
  "Updatable Arrays in Prolog", R.A.O'Keefe, DAI Working Paper 150.

Note that store(Index, Old, Elem, New) sometimes side-effects Old and
sometimes doesn't; you cannot rely on Old remaining unchanged.
(i.e. uninstantiated arguments in Old may become instantiated.)
This is NOT an example of logic programming.  For a logic programming
solution (with cost O(lgN) rather O(1)) see the TREES package.

The following sorting program illustrates the use of this package.

	%*% Demonstrate the ARRAYS package
	:- ensure_loaded([public(arrays)]).
	
	list_array_sort(List, SortedList) :-
		list_to_array(List, Array),
	
			write('Array before sorting: '), write(Array), nl,
	
		array_sort(Array, SortedArray),
	
			write('Sorted array: '), write(SortedArray), nl,
	
		array_to_list(SortedArray, SortedList).
	
	
	array_sort(Array, SortedArray) :-
		array_length(Array, Length),
	
			write('Array length: '), write(Length), nl,
	
		array_sort(Length, Array, SortedArray).
	
	array_sort(1, Array, Array).
	array_sort(N, Array, NewArray) :-
		N > 1,

			write('Handling position: '), write(N),

		array_max(N, Array, N, Position),

			write(' Max found at: '), write(Position),

		fetch(N, Array, NthElem),
		fetch(Position, Array, MaxElem),

			write(' (Value: '), write(MaxElem), write(')'), nl,

		store(Position, Array, NthElem, Array1),
		store(N,  Array1, MaxElem, Array2),

			write('Array after permutation: '), write(Array2), nl,

		N1 is N - 1,
		array_sort(N1, Array2, NewArray).


	array_max(0, _Array, PosMax, PosMax).

	array_max(Index, Array, PosMaxSoFar, PosMax) :-
		fetch(PosMaxSoFar, Array, MaxSoFar),
		fetch(Index, Array, Elem),
		Index1 is Index - 1,
		( Elem > MaxSoFar
		-> array_max(Index1, Array, Index, PosMax), !
		|  array_max(Index1, Array, PosMaxSoFar, PosMax)
		).


Sample execution:

	| ?- list_array_sort([3,2,1], L).
	Array before sorting:
	array([3|_000440E9],[2|_00044125],[1|_00044161]) + 0
	Array length: 3
	Handling position: 3 Max found at: 1 (Value: 3)
	Array after permutation:
	array([3,1|_00045075],[2|_00044125],[1,3|_00045269]) + 2
	Handling position: 2 Max found at: 2 (Value: 2)
	Array after permutation:
	array([1|_00046227],[2,2|_000464BB],[3|_0004629F]) + 1
	Sorted array: array([1|_00046227],[2,2|_000464BB],[3|_0004629F]) + 1
	L = [1,2,3] ;
	
	no


________________________________________________________________________

array_length/2

return the length of an array

	array_length(Array, Length)

	+Array		<term>
	-Length		<variable>

________________________________________________________________________

array_to_list/2

convert an array to a list

	array_to_list(Array, List)

	+Array		<term>
	-List		<variable>

________________________________________________________________________

fetch/3

fetch an element from an array

	fetch(Index, Array, Elem)

	+Index
	+Array
	-Element

________________________________________________________________________

list_to_array/2

convert a list to an array

	list_to_array(List, Array)

	+List		<list>
	-Array		<variable>


________________________________________________________________________

store/4

store an element into an array

	store(Index, Array, Elem, NewArray)

	+Index
	+Array
	+Element
	-NewArray

